---
title: 读《实战java高并发程序设计-葛一鸣》笔记
date: 2021-02-27 07:54:24
tags:
---

java并发的实际运用不管是在工作中还是在面试中，都有着相当重要的作用。所以想写一篇记录自己学习java并发实战的文章。

<!-- more -->

### 几个概念

1. 同步和异步：是指一种方法调用，同步的方法调用需要等待方法的结果返回，才能继续后续的操作。异步的的方法调用更像是一个消息传递。方法调用之后，不用等待方法返回结果，调用者就能继续后续的操作。
2. 并发和并行：并发是真正的多个任务同时执行，出现在有多核cpu的系统中；并发是多个任务交替执行，出现在只有一个cpu的系统中。
3. 临界区：表示一种公共资源或者共享数据。可以被多个线程使用，但是同时只能有一个线程使用，当临界区资源被占用，其他线程必须要等待。
4. 阻塞和非阻塞：用来形容多线程间的相互影响，比如一个线程占用了临界区的资源，其他所有需要这个资源的线程都会在临界区中等待，这种情况就是阻塞。非阻塞与其相反，没有一个线程会阻碍其他线程执行。
5. 死锁、饥饿、活锁：死锁是多个线程竞争同一个资源，并且互相不释放占有的资源，导致程序无法执行下去。

### 并发级别
1. 阻塞：一个线程是阻塞的，那么在其它线程释放资源之前，当前线程是无法继续执行的。使用synchronized或者重入锁，都会得到一个阻塞的线程。
2. 无饥饿：如果锁是不公平的，系统允许高优先级的线程插队，可能会引起低优先级的线程产生饥饿。如果锁是公平的，系统会限制所有将要获取资源的的线程都排队，那么饥饿就不会产生。
3. 无障碍：多个线程可以无障碍的进入同一个资源的临界区，并且不会被挂起，当一个线程检测到资源被另一个线程修改后，会对自己所做的修改进行回滚。无障碍的多线程不一定能顺利执行，因为在临界区中存在严重冲突时，有可能所有的线程会不断的回滚自己的操作，而没有一个线程可以走出临界区，这种情况会影响系统的正常运行。
> 一种可行的无障碍实现可以依赖一个“一致性标记”来实现。
> 线程在操作之前，需要读取并保存标记的状态。
> 操作完成之后，再次读取，检查该标记是否被更改过。
> 如果更改过，说明资源已经被修改，线程会进行重试操作。
> 如果没更改，说明资源访问没有冲突。
4. 无锁：无锁的并行都是无障碍的。在无锁的状态下，所有的线程都可以尝试对临界区进行访问。与无障碍不同的是，无锁的并发只保证有一个线程进入临界区完成操作并退出。无锁的特点是：会包含一个无限循环。
5. 无等待：