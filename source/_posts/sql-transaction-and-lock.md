---
title: 关于数据库中的事务和锁
date: 2018-11-13 21:40:09
tags:
---

### 事务

事务是由一组SQL查询或更新组成的独立的操作单元。事务中的SQL语句要么全部执行成功，要么全部执行失败。

<!-- more -->

#### 事务的特性

1. 原子性：一个事务必须是一组不可分割的最小操作单元。事务中的全部操作，要么全部提交成功，要么全部失败回滚。
2. 一致性：事务中的数据总是从一个一致性的状态转换到另一个一致性的状态。
3. 隔离性：一般情况下，一个事务的操作在提交成功之前，其他事务是看不到的。特殊情况下，不同的“隔离级别”，会有不同的隔离性。
4. 持久性：事务提交之后，其所做的修改会永久保存到数据库中。

#### 事务的隔离级别

数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，锁的应用最终导致不同事务的隔离级别。

1. read uncommitted（未提交读）：会产生脏读。
	- A事务开启，做了查询。
	- B事务开启，更新了一条数据，没有提交。
	- A事务查询，会得到B事务更新的数据，此时A事务读取到了脏数据，这种情况叫做脏读。
2. read committed（提交读）：会产生不可重复读。
	- A事务开启，做了查询。
	- B事务开启，更新了一条数据，没有提交。
	- A事务查询，得到的还是A事务原来的数据，此时**解决了A事务的脏读**。
	- B事务提交。
	- A事务查询，得到的是B事务更新并提交后的数据；此时A事务读取到的数据和前几次A事务读取的数据不一致，这个种情况叫做不可重复读。
3. repeatable read（可重复读）：会产生幻读。
	- A事务开启，做了查询。
	- B事务开启，更新了一条数据，并提交。
	- A事务查询，得到的还是A事务此前的数据，此时**解决了A事务的不可重复读**。
	- （InnoDB不会出现下面的情况）
	- B重新事务开启，新增了一条数据，并提交。
	- A事务查询，会得到B事务新增的一行数据，这行数据叫做幻行，这种情况叫做幻读。InnoDB通过**多版本并发控制（MVCC）**解决了幻读。
4. serializable
	- A事务开启，做了查询。
	- B事务开启，新增了一条数据，此时会插入失败；**解决了幻读问题**

### 锁

使用锁是为了支持对共享数据的并发访问，保证数据的一致性和完整性。

#### 锁的分类

1. 表锁
2. 行级锁。又可分为：
	- 共享锁（Shared lock），也成读锁。S锁与S锁之间兼容；S锁与X锁之间互斥。
	- 排它锁（Exclusive lock），也称写锁。X锁与X锁/S锁之间都互斥。

#### 锁的应用

1. read uncommitted；“读”不会加任何锁；“写”会加X锁，并到事务结束之后释放。
	- 上例中的A事务还能读取B事务中加了X锁的数据，是因为A事务没有加任何锁，不会被X锁排斥。
2. read committed；“读”不会加任何锁，使用MVCC机制读取了源数据的镜像版本；“写”会加X锁。
	- 
3. repeatable read；“读”不会加任何锁，使用MVCC机制读取了源数据的镜像版本；“写”会加X锁。
	- 
4. serializable；读加S锁，写加X锁

#### 多版本并发控制（MVCC）

只在read committed和repeatable read隔离级别下工作。